#!/bin/bash
#
# Copyright (c) 2024 Evgeny Sinelnikov <sin@altlinux.org>
#
# Disks diagnostic tool
#
# SPDX-License-Identifier: GPL-2.0-or-later
#

#trap 'echo "# $BASH_COMMAND";read' DEBUG

set -euo pipefail

. shell-getopt

PROG="${0##*/}"
PROG_VERSION='0.0.1'

cmd="run"
global_retval=0

disk=""

print_version()
{
	cat <<EOF
$PROG version $PROG_VERSION
Written by Evgeny Sinelnikov <sin@altlinux.org>

Copyright (C) 2024 Evgeny Sinelnikov <sin@altlinux.org>
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
EOF
	exit
}

show_usage()
{
	cat <<EOF
$PROG - disks diagnostic tool.

Usage: $PROG [options] [<diagnostic-task>]

Options:
  -l, --list                list of diagnostic tasks;
  -V, --version             print program version and exit;
  -h, --help                show this text and exit.

Report bugs to https://bugzilla.altlinux.org/

EOF
	exit
}

TEMP=$(getopt -n "$PROG" -o "l,V,h" -l "list,version,help" -- "$@") || show_usage
eval set -- "$TEMP"

while :; do
	case "$1" in
		--) shift; break
			;;
		-l|--list) cmd="list";
			;;
		-V|--version) print_version
			;;
		-h|--help) show_usage
			;;
		*) fatal "Unrecognized option: $1"
			;;
	esac
	shift
done

task_list="$*" #тут он начинает все вызывать

task_show()
{
	local func="$1"

	echo "$func"
}

task_run()
{
	local retval=126
	local func="$1"


	#Сюда заходим если запускаем один тест
	if test -n "$task_list"; then
		#записывает в тасклист тест что надо выполнить
		echo "$task_list" | tr ' ' '\n' | grep -q "^$func\$" ||
			return 0
		#echo ВЫВОДИК ТАСКЛИСТ $task_list
	fi
	#echo мы вызываем тест ДО === $task_list
	$func && retval=0 || retval="$?"
	test $retval = 0 || global_retval=1
	#echo мы вызываем тест

	return $retval
}

#добавить проверку на то какой тест вызывается
task()
{
	local task="$1"
	case "$cmd" in
		list) task_show "$task"
		#echo task_show
			;;
			# добавить условие что лист есть в списке... 
		run)
		#echo ТАСК ЛИСТ ==========$task_list 
		if test -z "$task_list" || grep "$task" <<< "$task_list"; then
			task_run "$task" && echo "[DONE]: $task" || echo "[FAIL]: $task"
		fi
			;;
		*) fatal "Unrecognized command: $cmd"
			;;
	esac
}

#пофиксить вывод результатов теста -DONE
#Пройтись по выводу приложения

find()
{
	local retval=0
	echo find '('$1')'
	grep " -d"  <<< $1 || retval=1
	echo retval == $retval
	return $retval
}

#Если несколько дисков, стоит добавить выбор конктретного...
get_disk()
{
	local retval=0
	local std_out_disk
	# disk=""
	# std_out_disk=$(smartctl --scan)
	std_out_disk="/dev/nvme0 -d nvme0 ssss # nvme0 SIS device"

	# "/dev/nvme0 -d nvme0 ssss # nvme0 SIS device /dev/fffff -d nvme0 ssss # nvme0 SIS device /dev/ddddd"


	# std_out_disk="/dev/nvme0 dfg fd"
	# std_out_disk=$(lsblk)

	grep " -d"  <<< $std_out_disk
	echo std_out_disk = $std_out_disk

	std_out_disk=${std_out_disk%" -d"*} # "/dev/nvme0 -d nvme0 ssss # nvme0 SIS device /dev/fffff -d nvme0 ssss # nvme0 SIS device /dev/ddddd"
	# Делай пока есть " -d"
	local while_res=0
	find "$std_out_disk" && while_res=1 || while_res=0
	echo ПЕРЕД ЦИКЛОМ while_res == $while_res
	while [ "$while_res" -eq "1" ]
	do
		disk=$disk${std_out_disk#*" device"} # /dev/fffff -d nvme0 ssss # nvme0 SIS device /dev/ddddd
		std_out_disk=${std_out_disk%" -d"*}
		echo
		echo ЗАШЛИ В ЦИКЛ
		echo disk = $disk
		echo std_out_disk = $std_out_disk
		echo
		find "$std_out_disk" && while_res=1 || while_res=0
		if [ "$while_res" -eq "0" ]
		then
			disk=$disk" "${std_out_disk%" -d"*}
		fi
		echo while_res = $while_res
		echo

	done

	
	echo ДИСКИ СИСТЕМЫ: $disk
	echo
	return $retval
}

is_disks()
{
	local retval=0
	#printf "\n"
	#echo Test - is_disks
	echo ================================
	lsblk || retval=1
	echo ================================
	return $retval
}

is_adout_disk()
{
	local retval=0
	local m_disk=""
	m_disk=$disk
	echo ================================
	echo is_adout_disk "------" $disk
	get_disk || retval=1
	while test -z $m_disk -eq true
	do
		local d
		d=${m_disk#*" "}
		echo ДИСК ТАКОЙ-ТО == $d
		smartctl -i $d

		m_disk=${m_disk%" "*}
	done


	smartctl -i $disk || retval=1
	echo ================================
	return $retval
}

#Проверка включенного SMART
#	Если не включен, то на всех тестах вывести предупреждение, что смарт не включен.
check_support_smart()
{
	local retval=0
	echo ================================
	get_disk || retval=1
	local disk_info
	disk_info=$(smartctl --info $disk)
	#Добавить ворнинг если есть поддержка, но не включен
	grep 'SMART support is:' <<< $disk_info || retval=1
	if [ $retval -eq 1 ]
		then
		echo S.M.A.R.T. is not supported.
	fi
	echo ================================
	return $retval
}

is_about_disk_status()
{
	local retval=0
	echo ================================
	get_disk || retval=1
	smartctl -A $disk || retval=1
	echo ================================
	return $retval
}

is_disk_health()
{
	local retval=0
	echo ================================
	get_disk || retval=1
	smartctl -H $disk | grep PASSED || retval=1
	echo ================================
	return $retval
}

#Заготова для теста
short_test_smartctl()
{
	local retval=0
	echo ================================
	get_disk
	smartctl -t short $disk || retval=1
	#добавить время через которое надо запустить...
	#добавить тест, который будет отдельно считывать selftest, чтоб и анализировать его. А тут напишем "запустите через N минут"
	smartctl -l selftest $disk
	echo ================================
	return $retval
}

task is_disks
task is_adout_disk
task check_support_smart
task is_about_disk_status
task is_disk_health
task short_test_smartctl

exit "$global_retval"
